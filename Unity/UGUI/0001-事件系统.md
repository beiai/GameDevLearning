# 事件处理流程

创建 UI 后默认会创建出 EventSystem 节点，并且添加了 EventSystem 和 StandaloneInputModule 组件

EventSystem 类全局最好只有一个，也只支持一个，多了没用也会有警告

## OnEnable

游戏运行后，两个组件执行类中的 OnEnable() 函数

但 StandaloneInputModule 类中没有 OnEnable() 函数

这是因为 StandaloneInputModule 还继承自 PointerInputModule 和 BaseInputModule

最终调用的是 BaseInputModule 中的 OnEnable() 函数

```c#
// 初始化 EventSystem 单例模式
EventSystem.OnEnable()
BaseInputModule.OnEnable()
// 获取该节点下所有的已激活输入模块
EventSystem.UpdateModules()
```

## Update

当 EventSystem 和 StandaloneInputModule 初始化完毕后

开始执行 EventSystem 的 Update() 函数

在 Update() 函数中需要更改输入模块，没懂这个用处在哪，猜测是因为早期还存在 TouchInputModule

如果 StandaloneInputModule 和 TouchInputModule 同时存在，则需要改变输入模块

```c#
// 所有输入模块调用一次 UpdateModule() 函数
EventSystem.TickModules()
// 更新当前及上一帧的鼠标位置
StandaloneInputModule.UpdateModule()
// 是否应该激活模块，如果没有任何输入事件发生，则不更新输入模块
StandaloneInputModule.ShouldActivateModule()
// 如果激活的输入模块和当前输入模块不相同，则更改当前输入模块
EventSystem.ChangeEventModule()
// 更新当前及上一帧的鼠标位置
StandaloneInputModule.ActivateModule()
// 设置 firstSelectedGameObject 默认选中物体
EventSystem.SetSelectedGameObject()
// 输入模块处理相关输入信息，更改输入模块后，下一帧才会执行
StandaloneInputModule.Process()
// 处理触摸事件
StandaloneInputModule.ProcessTouchEvents()
// 处理鼠标事件
StandaloneInputModule.ProcessMouseEvent()
// 处理导航事件
StandaloneInputModule.SendMoveEventToSelectedObject()
StandaloneInputModule.SendSubmitEventToSelectedObject()
```

## 触摸事件



## 鼠标事件

```C#
// 处理鼠标事件
StandaloneInputModule.ProcessMouseEvent()
StandaloneInputModule.ProcessMouseEvent(0)
// 获取当前鼠标位置的事件数据
PointerInputModule.GetMousePointerEventData(0)
// 先获取鼠标左键的事件数据，事件数据存放在字典缓存中，如果不存在则新创建一个
PointerInputModule.GetPointerData()

// 初始化事件的位置，如果不是新创建的，则先计算位置差值再初始化
PointerEventData.position
// 初始化事件的位置差值
PointerEventData.delta
// 如果鼠标状态是锁定状态，则禁用事件的位置和位置差值
Cursor.lockState == CursorLockMode.Locked
// 初始化事件的滚动差值
PointerEventData.scrollDelta
// 初始化事件的输入类型为左键
PointerEventData.button
// 
EventSystem.RaycastAll()
```



## 导航事件



# EventSystem

可以通过 current 获取 EventSystem 类的实例，类似单例模式

